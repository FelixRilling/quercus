{"version":3,"file":"quercus.common.js","sources":["esm/src/lookup/LookupStrategy.js","esm/src/tree/TreeNode.js"],"sourcesContent":["/**\n * Strategy to use when checking for a paths existence in a tree.\n * The strategy is used to check the final node only.\n *\n * @public\n */\nvar LookupStrategy;\n(function (LookupStrategy) {\n    /**\n     * Every node is considered to exist, regardless its value.\n     */\n    LookupStrategy[LookupStrategy[\"EXISTENCE_BY_NODE\"] = 0] = \"EXISTENCE_BY_NODE\";\n    /**\n     * Only nodes which have a non-nil value are considered existent.\n     */\n    LookupStrategy[LookupStrategy[\"EXISTENCE_BY_VALUE\"] = 1] = \"EXISTENCE_BY_VALUE\";\n})(LookupStrategy || (LookupStrategy = {}));\nexport { LookupStrategy };\n//# sourceMappingURL=LookupStrategy.js.map","import { isEmpty, isNil } from \"lodash\";\nimport { LookupStrategy } from \"../lookup/LookupStrategy\";\n/**\n * Default implementation of a tree, using nested maps.\n *\n * @public\n * @class\n */\nclass TreeNode {\n    /**\n     * Creates a new instance with an optional value.\n     *\n     * @param value Value to instantiate the node with. If none is provided, null is set.\n     */\n    constructor(value = null) {\n        this.value = value;\n        this.paths = new Map();\n    }\n    /**\n     * Checks if a given path exists in this tree.\n     *\n     * @public\n     * @param path Path to check for. May not be empty.\n     * @param lookupStrategy Strategy to use. See {@link LookupStrategy} for details.\n     * @return if the path exists, based on the strategy used.\n     */\n    hasPath(path, lookupStrategy = LookupStrategy.EXISTENCE_BY_NODE) {\n        this.validatePath(path);\n        const lookupResult = this.resolvePath(path, 0 /* RETURN_ON_MISSING */);\n        if (isNil(lookupResult.node)) {\n            return false;\n        }\n        if (lookupStrategy === LookupStrategy.EXISTENCE_BY_NODE) {\n            return true;\n        }\n        return !isNil(lookupResult.node.value);\n    }\n    /**\n     * Gets a given path in this tree.\n     *\n     * @public\n     * @param path Path to get. May not be empty.\n     * @return lookup result, containing details about which node was retrieved and what path was used.\n     */\n    getPath(path) {\n        this.validatePath(path);\n        return this.resolvePath(path, 0 /* RETURN_ON_MISSING */);\n    }\n    /**\n     * Sets a value or node for a given path.\n     * Middle nodes will be created automatically.\n     *\n     * @public\n     * @param path Path to set the value for. May not be empty.\n     * @param value Value or node to set.\n     */\n    setPath(path, value) {\n        this.validatePath(path);\n        const lookupResult = this.resolvePath(path, 1 /* CREATE_MISSING */);\n        if (value instanceof TreeNode) {\n            lookupResult.parent.node.paths.set(lookupResult.parent.key, value);\n        }\n        else {\n            lookupResult.node.value = value;\n        }\n    }\n    /**\n     * Resolves the path against this tree.\n     *\n     * @private\n     * @param path Path to resolve\n     * @param resolverStrategy Strategy to use for non-existent nodes.\n     * @param previousPath Only used for recursive calls. Path the resolving was delegated from.\n     * @return Lookup result.\n     */\n    resolvePath(path, resolverStrategy, previousPath = []) {\n        const key = path[0];\n        let node;\n        if (!this.paths.has(key)) {\n            if (resolverStrategy !== 1 /* CREATE_MISSING */) {\n                return {\n                    node: null,\n                    parent: {\n                        node: this,\n                        key\n                    },\n                    matchedPath: previousPath,\n                    trailingPath: path\n                };\n            }\n            node = new TreeNode();\n            this.paths.set(key, node);\n        }\n        else {\n            node = this.paths.get(key);\n        }\n        const previousPathNew = Array.from(previousPath);\n        previousPathNew.push(key);\n        if (path.length === 1) {\n            return {\n                node,\n                parent: {\n                    node: this,\n                    key\n                },\n                matchedPath: previousPathNew,\n                trailingPath: []\n            };\n        }\n        const nextPath = path.slice(1);\n        return node.resolvePath(nextPath, resolverStrategy, previousPathNew);\n    }\n    /**\n     * Validates a given path.\n     *\n     * @param path Path to check.\n     * @private\n     */\n    validatePath(path) {\n        if (isEmpty(path)) {\n            throw new TypeError(\"Path may not be empty.\");\n        }\n    }\n}\nexport { TreeNode };\n//# sourceMappingURL=TreeNode.js.map"],"names":["LookupStrategy","isNil","isEmpty"],"mappings":"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"}