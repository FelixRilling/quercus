{"version":3,"file":"quercus.common.js","sources":["esm/src/lookup/LookupStrategy.js","esm/src/tree/ResolverStrategy.js","esm/src/tree/NestedMapTree.js"],"sourcesContent":["/**\n * Strategy to use when checking for a paths existence in a tree.\n * The strategy is used to check the final node only.\n *\n * @public\n */\nvar LookupStrategy;\n(function (LookupStrategy) {\n    /**\n     * Every node is considered to exist, regardless its value.\n     */\n    LookupStrategy[LookupStrategy[\"EXISTENCE_BY_NODE\"] = 0] = \"EXISTENCE_BY_NODE\";\n    /**\n     * Only nodes which have a non-nil value are considered existent.\n     */\n    LookupStrategy[LookupStrategy[\"EXISTENCE_BY_VALUE\"] = 1] = \"EXISTENCE_BY_VALUE\";\n})(LookupStrategy || (LookupStrategy = {}));\nexport { LookupStrategy };\n//# sourceMappingURL=LookupStrategy.js.map","/**\n * Strategy to use when resolving tree nodes internally.\n *\n * @private\n */\nvar ResolverStrategy;\n(function (ResolverStrategy) {\n    /**\n     * Return immediately when a node cannot be found.\n     * This is usually wanted when looking up an entry that might exist.\n     */\n    ResolverStrategy[ResolverStrategy[\"RETURN_ON_MISSING\"] = 0] = \"RETURN_ON_MISSING\";\n    /**\n     * Create missing nodes dynamically and continue.\n     * This is used when setting a new value that has non-existent middle nodes.\n     */\n    ResolverStrategy[ResolverStrategy[\"CREATE_MISSING\"] = 1] = \"CREATE_MISSING\";\n})(ResolverStrategy || (ResolverStrategy = {}));\nexport { ResolverStrategy };\n//# sourceMappingURL=ResolverStrategy.js.map","import { isEmpty, isNil } from \"lodash\";\nimport { LookupStrategy } from \"../lookup/LookupStrategy\";\nimport { ResolverStrategy } from \"./ResolverStrategy\";\n/**\n * Default implementation of a tree, using nested maps.\n *\n * @public\n * @class\n */\nclass NestedMapTree {\n    /**\n     * Creates an empty instance.\n     */\n    constructor() {\n        this.node = this.createNode();\n    }\n    /**\n     * Sets a value for a given path.\n     * Middle nodes will be created automatically.\n     *\n     * @public\n     * @param path Path to set the value for. May not be empty.\n     * @param value Value to set.\n     */\n    setPath(path, value) {\n        this.validatePath(path);\n        const lookupResult = this.resolve(path, ResolverStrategy.CREATE_MISSING);\n        const node = lookupResult.node;\n        node.value = value;\n    }\n    /**\n     * Checks if a given path exists in this tree.\n     *\n     * @public\n     * @param path Path to check for. May not be empty.\n     * @param lookupStrategy Strategy to use. See {@link LookupStrategy} for details.\n     * @return if the path exists, based on the strategy used.\n     */\n    hasPath(path, lookupStrategy = LookupStrategy.EXISTENCE_BY_NODE) {\n        this.validatePath(path);\n        const lookupResult = this.resolve(path, ResolverStrategy.RETURN_ON_MISSING);\n        if (isNil(lookupResult.node)) {\n            return false;\n        }\n        if (lookupStrategy === LookupStrategy.EXISTENCE_BY_NODE) {\n            return true;\n        }\n        return !isNil(lookupResult.node.value);\n    }\n    /**\n     * Gets a given path in this tree.\n     *\n     * @public\n     * @param path Path to get. May not be empty.\n     * @return lookup result, containing details about which node was retrieved and what path was used.\n     */\n    getPath(path) {\n        this.validatePath(path);\n        return this.resolve(path, ResolverStrategy.RETURN_ON_MISSING);\n    }\n    /**\n     * Resolves a path.\n     *\n     * @private\n     * @param path Path to get.\n     * @param resolverStrategy Strategy to use during resolving.\n     * @return lookup result, containing details about which node was retrieved and what path was used.\n     */\n    resolve(path, resolverStrategy) {\n        let node = this.node;\n        for (let i = 0; i < path.length; i++) {\n            const key = path[i];\n            if (!node.map.has(key)) {\n                if (resolverStrategy !== ResolverStrategy.CREATE_MISSING) {\n                    return {\n                        node: null,\n                        matchedPath: path.slice(0, i),\n                        trailingPath: path.slice(i)\n                    };\n                }\n                const newNode = this.createNode();\n                node.map.set(key, newNode);\n                node = newNode;\n            }\n            else {\n                node = node.map.get(key);\n            }\n        }\n        return {\n            node,\n            matchedPath: path,\n            trailingPath: []\n        };\n    }\n    /**\n     * Creates a new (sub-)node\n     *\n     * @private\n     * @return new node.\n     */\n    createNode() {\n        return { value: null, map: new Map() };\n    }\n    /**\n     * Validates a given path.\n     *\n     * @param path Path to check.\n     * @private\n     */\n    validatePath(path) {\n        if (isEmpty(path)) {\n            throw new TypeError(\"Path may not be empty.\");\n        }\n    }\n}\nexport { NestedMapTree };\n//# sourceMappingURL=NestedMapTree.js.map"],"names":["LookupStrategy","isNil","isEmpty"],"mappings":"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"}