{"version":3,"file":"quercus.common.js","sources":["esm/src/path/resolvePath.js","esm/src/Quercus.js"],"sourcesContent":["/**\n * Resolves path through Quercus instances.\n *\n * @private\n * @since 1.0.0\n * @param {Tree} targetOld Starting target for resolving.\n * @param {any[]} path Path to resolve.\n * @param {boolean} [createMissing=false] If requested instances should be created if they don't exist.\n * @returns {object} Resolved path object.\n * @example\n * const q = new Tree([[\"foo\", \"bar\"], 5]);\n *\n * resolvePath(q, [\"foo\", \"bar\"])\n * // => {target: Tree{\"bar\": 5}, key: \"bar\", success: true}\n */\nconst resolvePath = (targetOld, path, createMissing = false) => {\n    let target = targetOld;\n    let key = path[0];\n    let success = true;\n    if (path.length > 1) {\n        const sub = targetOld.get(key);\n        /*\n         * Does the key exist on the target?\n         *     true  -> Assign it\n         *     false ->\n         *         Is createMissing truthy?\n         *             true  -> Create a new Quercus, assign it and set it on the parent.\n         *             false -> Declare unsuccessful, abort.\n         */\n        if (targetOld.has(key) && targetOld.isTree(sub)) {\n            target = sub;\n        }\n        else {\n            if (createMissing) {\n                target = targetOld.createSubTree();\n                targetOld.set(key, target);\n            }\n            else {\n                success = false;\n            }\n        }\n        // Assign the next key\n        key = path[1];\n    }\n    if (path.length > 2 && success) {\n        return resolvePath(target, path.slice(1), createMissing);\n    }\n    return { target, key, success };\n};\nexport { resolvePath };\n//# sourceMappingURL=resolvePath.js.map","import { resolvePath } from \"./path/resolvePath\";\n/**\n * Quercus main class.\n *\n * @class\n * @since 1.0.0\n * @extends Map\n */\nclass Quercus extends Map {\n    /**\n     * Quercus main constructor.\n     *\n     * @constructor\n     * @since 1.0.0\n     * @param {Array<Array<any>, any>} [pairArr=[]] Optional array of path-value pairs to init.\n     * @example\n     * // Empty tree\n     * const q = new Quercus();\n     *\n     * // Tree initialized with a path-value pair\n     * const q2 = new Quercus([[\"foo\", bar], 5]);\n     */\n    constructor(pairArr = []) {\n        super();\n        for (const [path, val] of pairArr) {\n            this.setPath(path, val);\n        }\n    }\n    /**\n     * Checks if a given path exists.\n     *\n     * @since 1.0.0\n     * @param {any[]} path Path to check.\n     * @param {boolean} [quercusNodesAreTruthy=false] If nodes should be considered to be truthy.\n     * @returns {boolean} If the given path exists.\n     * @example\n     * const q = new Quercus([\n     *       [[\"foo\", \"bar\"], 5],\n     *       [[\"foo\", \"bizz\"], 12],\n     *       [[\"bar\", \"fazz\"], 560]\n     *   ]);\n     *\n     * q.hasPath([\"foo\", \"bar\"]);\n     * // => true\n     *\n     * q.hasPath([\"foo\"]);\n     * // => false\n     *\n     * q.hasPath([\"foo\"], true);\n     * // => true\n     */\n    hasPath(path, quercusNodesAreTruthy = false) {\n        if (path.length === 0) {\n            return quercusNodesAreTruthy;\n        }\n        const { target, key, success } = resolvePath(this, path);\n        if (success && target.has(key)) {\n            if (!quercusNodesAreTruthy) {\n                return !this.isTree(target.get(key));\n            }\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Returns value of a given path.\n     *\n     * If the path could not be found, null is returned.\n     *\n     * @since 1.0.0\n     * @param {any[]} path Path to get.\n     * @returns {any|null} Value of the node, or null if it is not found.\n     * @example\n     * const q = new Quercus([\n     *       [[\"foo\", \"bar\"], 5],\n     *       [[\"foo\", \"bizz\"], 12],\n     *       [[\"bar\", \"fazz\"], 560]\n     *   ]);\n     *\n     * q.getPath([\"foo\", \"bar\"]);\n     * // => 5\n     *\n     * q.getPath([\"bar\"]);\n     * // => Quercus{\"fazz\": 560}\n     *\n     * q.getPath([\"lorem\"]);\n     * // => null\n     */\n    getPath(path) {\n        if (path.length === 0) {\n            return this;\n        }\n        const { target, key, success } = resolvePath(this, path);\n        if (success && target.has(key)) {\n            return target.get(key);\n        }\n        return null;\n    }\n    /**\n     * Sets value of a given path.\n     *\n     * If the given path is empty, null is returned.\n     * If the value was set successfully, the value's Node is returned.\n     *\n     * @since 1.0.0\n     * @param {any[]} path Path to set.\n     * @param {any} val Value to set.\n     * @returns {Quercus|null} Node that was set on, or null if it could not be set.\n     * @example\n     * const q = new Quercus();\n     *\n     * q.setPath([\"foo\", \"bar\"], 5);\n     * // => Quercus{\"bar\": 5}\n     *\n     * q.setPath([\"bar\", \"fazz\"], 560);\n     * // => Quercus{\"fazz\": 560}\n     *\n     * q.setPath([], \"foo\");\n     * // => null\n     */\n    setPath(path, val) {\n        if (path.length === 0) {\n            return null;\n        }\n        const { target, key } = resolvePath(this, path, true);\n        target.set(key, val);\n        return target;\n    }\n    isTree(val) {\n        return val instanceof Quercus;\n    }\n    createSubTree() {\n        return new Quercus();\n    }\n}\nexport { Quercus };\n//# sourceMappingURL=Quercus.js.map"],"names":[],"mappings":"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"}