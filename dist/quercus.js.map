{"version":3,"file":"quercus.js","sources":["../node_modules/lightdash/dist/lightdash.esm.js"],"sourcesContent":["/**\n * Checks if the value has a certain type-string.\n *\n * @function isTypeOf\n * @memberof Is\n * @since 1.0.0\n * @param {any} val\n * @param {string} type\n * @returns {boolean}\n * @example\n * // returns true\n * isTypeOf({}, \"object\")\n * isTypeOf([], \"object\")\n * isTypeOf(\"foo\", \"string\")\n *\n * @example\n * // returns false\n * isTypeOf(\"foo\", \"number\")\n */\nconst isTypeOf = (val, type) => typeof val === type;\n\n/**\n * Checks if a value is a function.\n *\n * @function isFunction\n * @memberof Is\n * @since 1.0.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * // returns true\n * isFunction(function a(){})\n * isFunction(() => 1)\n *\n * @example\n * // returns false\n * isFunction(null)\n */\nconst isFunction = (val) => isTypeOf(val, \"function\");\n\n/**\n * Checks if a value is an arguments array-like.\n *\n * @function isArguments\n * @memberof Is\n * @since 2.10.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * // returns true\n * const foo = function(){\n *   return arguments;\n * };\n *\n * isArguments(foo());\n *\n * @example\n * // returns false\n * isArguments([]);\n */\nconst isArguments = (val) => isFunction(val.callee);\n\n// tslint:disable\n/*\n * Using this can really reduce the minified output but can have optimization issues\n */\nconst _Number = Number;\nconst _Object = Object;\nconst _Array = Array;\nconst _Set = Set;\nconst _Map = Map;\nconst _Math = Math;\n\n/**\n * Checks if a value is an array.\n *\n * `Array.isArray` shorthand.\n *\n * @function isArray\n * @memberof Is\n * @since 1.0.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * // returns true\n * isArray([]);\n * isArray([1, 2, 3]);\n *\n * @example\n * // returns false\n * isArray({});\n */\nconst isArray = _Array.isArray;\n\n/**\n * Checks if the value is an instance of a target constructor.\n *\n * @function isInstanceOf\n * @memberof Is\n * @since 1.0.0\n * @param {any} val\n * @param {Class} target\n * @returns {boolean}\n * @example\n * // returns true\n * isInstanceOf({}, Object)\n * isInstanceOf([], Object)\n * isInstanceOf([], Array)\n *\n * @example\n * // returns false\n * isInstanceOf({}, Array)\n * isInstanceOf([], Map)\n */\nconst isInstanceOf = (val, target) => val instanceof target;\n\n/**\n * Checks if a value is an array-buffer.\n *\n * @function isArrayBuffer\n * @memberof Is\n * @since 2.10.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * // returns true\n * isArrayBuffer(new ArrayBuffer())\n *\n * @example\n * // returns false\n * isArrayBuffer([1, 2])\n */\n// @ts-ignore: ArrayBuffer declaration is outdated\nconst isArrayBuffer = (val) => isInstanceOf(val, ArrayBuffer);\n\n/**\n * Checks if a value is undefined.\n *\n * @function isUndefined\n * @memberof Is\n * @since 1.0.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * // returns false\n * const a = {};\n *\n * isUndefined(a.b)\n * isUndefined(undefined)\n *\n * @example\n * // returns false\n * const a = {};\n *\n * isUndefined(1)\n * isUndefined(a)\n */\nconst isUndefined = (val) => isTypeOf(val, \"undefined\");\n\n/**\n * Checks if a value is defined.\n *\n * @function isDefined\n * @memberof Is\n * @since 1.0.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * // returns true\n * const a = {};\n *\n * isDefined(1)\n * isDefined(a)\n *\n * @example\n * // returns false\n * const a = {};\n *\n * isDefined(a.b)\n * isDefined(undefined)\n */\nconst isDefined = (val) => !isUndefined(val);\n\n/**\n * Checks if a target has a certain key.\n *\n * @function hasKey\n * @memberof Has\n * @since 1.0.0\n * @param {any} target\n * @param {string} key\n * @returns {boolean}\n * @example\n * // returns true\n * hasKey([1, 2, 3], \"0\")\n * hasKey({foo: 0}, \"foo\")\n * hasKey(\"foo\", \"replace\")\n *\n * @example\n * // returns false\n * hasKey({}, \"foo\")\n */\nconst hasKey = (target, key) => isDefined(target[key]);\n\n/**\n * Checks if a value is undefined or null.\n *\n * @function isNil\n * @memberof Is\n * @since 1.0.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * // returns true\n * isNil(null)\n * isNil(undefined)\n *\n * @example\n * // returns false\n * isNil(0)\n * isNil({})\n */\nconst isNil = (val) => isUndefined(val) || val === null;\n\n/**\n * Checks if a value is not nil and has a type of object.\n *\n * The main difference to isObject is that functions are not considered object-like,\n * because `typeof function(){}` returns \"function\".\n *\n * @function isObjectLike\n * @memberof Is\n * @since 1.0.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * // returns true\n * isObjectLike({})\n * isObjectLike([])\n *\n * @example\n * // returns false\n * isObjectLike(1)\n * isObjectLike(() => 1))\n */\nconst isObjectLike = (val) => !isNil(val) && isTypeOf(val, \"object\");\n\n/**\n * Checks if a value is object-like and has a length property.\n *\n * @function isArrayLike\n * @memberof Is\n * @since 1.0.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * // returns true\n * isArrayLike([])\n * isArrayLike({length: 0})\n *\n * @example\n * // returns false\n * isArrayLike({})\n * isArrayLike(null)\n * isArrayLike(\"foo\")\n * isArrayLike(1)\n */\nconst isArrayLike = (val) => isObjectLike(val) && hasKey(val, \"length\");\n\n/**\n * Checks if a value is a number.\n *\n * @function isNumber\n * @memberof Is\n * @since 1.0.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * // returns true\n * isNumber(1)\n * isNumber(2.34)\n * isNumber(Infinity)\n * isNumber(NaN)\n *\n * @example\n * // returns false\n * isNumber(\"2\")\n * isNumber(null)\n */\nconst isNumber = (val) => isTypeOf(val, \"number\");\n\n/**\n * Checks if a value is a typed array.\n *\n * @function isArrayTyped\n * @memberof Is\n * @since 2.10.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * // returns true\n * isArrayTyped(new Int16Array());\n * isArrayTyped(new Uint8Array());\n *\n * @example\n * // returns false\n * isArrayTyped([]);\n */\nconst isArrayTyped = (val) => isNumber(val.BYTES_PER_ELEMENT);\n\n/**\n * Checks if a value is a boolean.\n *\n * @function isBoolean\n * @memberof Is\n * @since 1.0.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * // returns true\n * isBoolean(true)\n * isBoolean(false)\n *\n * @example\n * // returns false\n * isBoolean(0)\n * isBoolean(null)\n * isBoolean(\"\")\n */\nconst isBoolean = (val) => isTypeOf(val, \"boolean\");\n\n/**\n * Checks if a value is a date object.\n *\n * @function isDate\n * @memberof Is\n * @since 2.10.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * // returns true\n * isDate(Date())\n * isDate(new Date())\n *\n * @example\n * // returns false\n * isDate(123213)\n */\nconst isDate = (val) => isInstanceOf(val, Date);\n\n/**\n * Returns an array of the objects keys.\n *\n * `Object.keys` shorthand.\n *\n * @function objKeys\n * @memberof Object\n * @since 1.0.0\n * @param {Object} obj\n * @returns {any[]}\n * @example\n * // returns [\"a\", \"b\", \"c\"]\n * objKeys({a: 1, b: 2, c: 3})\n */\nconst objKeys = _Object.keys;\n\n/**\n * Checks if a value is empty.\n *\n * A value is consider empty if it is either a primitive or an object-like without content.\n * Array-likes are considered empty if they have a length of zero,\n * Sets/Maps if they have a size of zero,\n * and Objects if their keys have a length of zero.\n *\n * @function isEmpty\n * @memberof Is\n * @since 1.0.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * // returns true\n * isEmpty([])\n * isEmpty({})\n * isEmpty(\"\")\n * isEmpty(true)\n * isEmpty(1)\n * isEmpty(null)\n *\n * @example\n * // returns false\n * isEmpty(\"foo\")\n * isEmpty([1, 2])\n * isEmpty({a: 1})\n */\nconst isEmpty = (val) => {\n    if (isArrayLike(val)) {\n        return val.length === 0;\n    }\n    else if (hasKey(val, \"size\")) {\n        return val.size === 0;\n    }\n    else if (isObjectLike(val)) {\n        return objKeys(val).length === 0;\n    }\n    return true;\n};\n\n/**\n * Returns an array of the objects entries.\n *\n * `Object.entries` shorthand.\n *\n * @function objEntries\n * @memberof Object\n * @since 1.0.0\n * @param {Object} obj\n * @returns {any[]} Array<[key: any, val: any]>]\n * @example\n * // returns [[\"a\", 1], [\"b\", 2], [\"c\", 3]]\n * objEntries({a: 1, b: 2, c: 3})\n */\nconst objEntries = _Object.entries;\n\n/**\n * Iterates over each element in an array\n *\n * Wrapper around arr.forEach to have a cleaner API and better minified code\n *\n * @function forEach\n * @memberof For\n * @param {any[]} arr\n * @param {function} fn fn(val: any, index: number, arr: any[])\n * @example\n * // returns a = [0, 2, 6]\n * const a = [1, 2, 3];\n *\n * forEach(a, (val, index)=>a[index] = val * index)\n */\nconst forEach = (arr, fn) => arr.forEach(fn);\n\n/**\n * Iterates over each entry of an object\n *\n * @function forEachEntry\n * @memberof For\n * @param {object} obj\n * @param {function} fn fn(key: any, val: any, index: number, arr: any[])\n * @example\n * // returns a = {a: 0, b: 2}\n * const a = {a: 1, b: 2};\n *\n * forEachEntry(a, (key, val, index) => a[key] = val * index)\n */\nconst forEachEntry = (obj, fn) => {\n    forEach(objEntries(obj), (entry, index) => {\n        fn(entry[0], entry[1], index, obj);\n    });\n};\n\n/**\n * Recursively checks if two items and their the contents are equal.\n *\n * @function isEqual\n * @memberof Is\n * @since 1.0.0\n * @param {any} a\n * @param {any} b\n * @returns {boolean}\n * @example\n * // returns true\n * isEqual(1, 1)\n * isEqual({}, {})\n * isEqual([1, 2], [1, 2])\n * isEqual([1, 2, [3, 4]], [1, 2, [3, 4]])\n *\n * @example\n * // returns false\n * isEqual([1, 2, 3], [1])\n * isEqual([1, 2, [3]], [1, 2, [4]])\n */\nconst isEqual = (a, b) => {\n    if (a === b) {\n        return true;\n    }\n    if (isObjectLike(a) &&\n        isObjectLike(b) &&\n        objKeys(a).length === objKeys(b).length) {\n        let result = true;\n        forEachEntry(a, (key, aVal) => {\n            // Only check if the comparison didn't fail already\n            if (result === true) {\n                if (hasKey(b, key)) {\n                    result = isEqual(aVal, b[key]);\n                }\n                else {\n                    result = false;\n                }\n            }\n        });\n        return result;\n    }\n    return false;\n};\n\n/**\n * Checks if a value is an error.\n *\n * @function isError\n * @memberof Is\n * @since 2.10.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * // returns true\n * isError(new Error())\n * isError(new URIError())\n *\n * @example\n * // returns false\n * isError(\"foo\")\n */\nconst isError = (val) => isInstanceOf(val, Error);\n\n/**\n * Checks if a value is an integer.\n *\n * `Number.isInteger` shorthand.\n *\n * @function isInteger\n * @memberof Is\n * @since 2.10.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * // returns true\n * isInteger(1);\n * isInteger(2000);\n *\n * @example\n * // returns false\n * isInteger(2.34);\n * isInteger(Infinity)\n */\nconst isInteger = _Number.isInteger;\n\n/**\n * Checks if a value is a map.\n *\n * @function isMap\n * @memberof Is\n * @since 1.0.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * // returns true\n * isMap(new Map())\n *\n * @example\n * // returns false\n * isMap([[1, 2]])\n */\nconst isMap = (val) => isInstanceOf(val, _Map);\n\n/**\n * Checks if a value is an object.\n *\n * @function isObject\n * @memberof Is\n * @since 1.0.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * // returns true\n * isObject({})\n * isObject([])\n * isObject(() => 1))\n *\n * @example\n * // returns false\n * isObject(1)\n */\nconst isObject = (val) => !isNil(val) && (isTypeOf(val, \"object\") || isTypeOf(val, \"function\"));\n\n/**\n * Checks if a value is a plain object.\n *\n * An object is considered plain of its direct constructor is the built-in object constructor.\n *\n * @function isObjectPlain\n * @memberof Is\n * @since 2.9.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * // returns true\n * isObjectPlain({})\n *\n * @example\n * // returns false\n * isObjectPlain([])\n * isObjectPlain(()=>{})\n */\nconst isObjectPlain = (val) => isObject(val) && val.constructor === _Object;\n\n/**\n * Checks if a value is primitive.\n *\n * @function isPrimitive\n * @memberof Is\n * @since 1.0.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * // returns true\n * isPrimitive(1)\n * isPrimitive(null)\n *\n * @example\n * // returns false\n * isPrimitive({})\n * isPrimitive([])\n */\nconst isPrimitive = (val) => !isObject(val);\n\n/**\n * Checks if a value is a promise.\n *\n * @function isPromise\n * @memberof Is\n * @since 3.0.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * // returns true\n * const foo = new Promise((resolve, reject) => resolve(\"foo\"));\n *\n * isPromise(foo);\n *\n * @example\n * // returns false\n * isPromise(() => \"foo\");\n */\nconst isPromise = (val) => isFunction(val.then) && isFunction(val.catch);\n\n/**\n * Checks if a value is a regular expression.\n *\n * @function isRegExp\n * @memberof Is\n * @since 2.10.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * // returns true\n * isRegExp(new RegExp(\"foo\"))\n * isRegExp(/foo/)\n *\n * @example\n * //returns false\n * isRegExp(\"foo\")\n */\n// @ts-ignore: RegExp declaration is outdated\nconst isRegExp = (val) => isInstanceOf(val, RegExp);\n\n/**\n * Checks if a value is a set.\n *\n * @function isSet\n * @memberof Is\n * @since 1.0.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * // returns true\n * isSet(new Set())\n *\n * @example\n * // returns false\n * isSet([1, 2])\n */\nconst isSet = (val) => isInstanceOf(val, _Set);\n\n/**\n * Checks if a value is a string.\n *\n * @function isString\n * @memberof Is\n * @since 1.0.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * // returns true\n * isString(\"foo\")\n *\n * @example\n * // returns false\n * isString(1)\n */\nconst isString = (val) => isTypeOf(val, \"string\");\n\n/**\n * Checks if a value is a symbol.\n *\n * @function isSymbol\n * @memberof Is\n * @since 1.0.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * // returns true\n * isSymbol(Symbol())\n * isSymbol(Symbol.split)\n *\n * @example\n * // returns false\n * isSymbol(\"foo\")\n */\nconst isSymbol = (val) => isTypeOf(val, \"symbol\");\n\n/**\n * Checks if an object has a certain own key.\n *\n * `obj.hasOwnProperty` shorthand.\n *\n * @function hasOwnProperty\n * @memberof Has\n * @since 2.8.0\n * @param {Object} obj\n * @param {string} key\n * @returns {boolean}\n * @example\n * // returns true\n * hasOwnProperty([1, 2, 3], \"0\")\n * hasOwnProperty({foo: 0}, \"foo\")\n *\n * @example\n * // returns false\n * hasOwnProperty([], \"forEach\")\n * hasOwnProperty(\"foo\", \"replace\")\n */\nconst hasOwnProperty = (obj, key) => obj.hasOwnProperty(key);\n\n/**\n * Accesses a target by a path-array of key-strings.\n *\n * If the path doesn't exist, null is returned.\n *\n * @function getPath\n * @memberof Get\n * @since 2.0.0\n * @param {any} target\n * @param {string[]} path\n * @returns {boolean}\n * @example\n * getPath({a: 1}, [\"a\"]);                              //=> 1\n * getPath([4, 6, 8], [\"1\"]);                           //=> 6\n * getPath({a: {b: 2, c: [10, 20]}}, [\"a\", \"c\", \"0\"]);  //=> 10\n */\nconst getPath = (target, path) => {\n    let targetCurrent = target;\n    let index = 0;\n    while (isDefined(targetCurrent) && index < path.length) {\n        const keyCurrent = path[index];\n        if (!hasKey(targetCurrent, keyCurrent)) {\n            return null;\n        }\n        targetCurrent = targetCurrent[keyCurrent];\n        index++;\n    }\n    return targetCurrent;\n};\n\n/**\n * Checks if a target has a path-array of key-strings.\n *\n * @function hasPath\n * @memberof Has\n * @since 2.0.0\n * @param {any} target\n * @param {string[]} path\n * @returns {boolean}\n * @example\n * // returns true\n * hasPath({a: 1}, [\"a\"]);\n * hasPath([4, 6, 8], [\"1\"]);\n * hasPath({a: {b: 2, c: [10, 20]}}, [\"a\", \"c\", \"0\"]);\n *\n * @example\n * // returns false\n * hasPath({a: 1}, [\"c\"]);\n * hasPath([4, 6, 8], [\"8\"]);\n * hasPath({a: {b: 2, c: [10, 20]}}, [\"f\", \"x\", \"231\", \"21\"]);\n * hasPath(1, [\"foo\"]);\n */\nconst hasPath = (target, path) => !isNil(getPath(target, path));\n\n/**\n * Recursively iterates over each element in an array\n *\n * @function forEachDeep\n * @memberof For\n * @param {any[]} arr\n * @param {function} fn fn(val: any, index: number, arr: any[])\n * @example\n * // returns a = [0, 4, [0, 1, [0], 12]]\n * const a = [2, 4, [1, 1, [16], 4]];\n *\n * forEachDeep(a, (val, index, arr) => arr[index] = index * val)\n */\nconst forEachDeep = (arr, fn) => forEach(arr, (val, index) => isArray(val) ? forEachDeep(val, fn) : fn(val, index, arr));\n\n/**\n * Recursively iterates over each entry of an object\n *\n * @function forEachEntryDeep\n * @memberof For\n * @param {object} obj\n * @param {function} fn fn(key: any, val: any, index: number, arr: any[])\n * @example\n * // returns {a: 0, b: {c: [0, 2]}}\n * const a = {a: 1, b: {c: [1, 2]}};\n *\n * forEachEntryDeep(a, (key, val, index, obj) => obj[key] = index * val)\n */\nconst forEachEntryDeep = (obj, fn) => forEachEntry(obj, (key, val, index) => isObjectLike(val)\n    ? forEachEntryDeep(val, fn)\n    : fn(key, val, index, obj));\n\n/**\n * Execute a function n times\n *\n * Wrapper around a simple for-loop to have better minified code\n *\n * @function forTimes\n * @memberof For\n * @param {number} start\n * @param {number} max\n * @param {number} increase\n * @param {function} fn fn(index: number)\n * @example\n * // returns a = [2, 4, 6, 8, 10]\n * const a = [];\n *\n * forTimes(1, 6, 1, index => a.push(index * 2))\n */\nconst forTimes = (start, max, increase, fn) => {\n    for (let index = start; index <= max; index += increase) {\n        fn(index);\n    }\n};\n\n/**\n * Creates an array of elements split into groups by size.\n *\n * @function arrChunk\n * @memberof Array\n * @since 2.0.0\n * @param {any[]} arr\n * @param {number} chunk\n * @returns {any[]}\n * @example\n * // returns [[1, 2], [3, 4], [5, 6]]\n * arrChunk([1, 2, 3, 4, 5, 6], 2)\n *\n * @example\n * // returns [[1, 2, 3], [4, 5]]\n * arrChunk([1, 2, 3, 4, 5], 3)\n */\nconst arrChunk = (arr, chunk) => {\n    if (chunk < 1) {\n        return [];\n    }\n    const result = [];\n    forTimes(0, arr.length - 1, chunk, (index) => {\n        result.push(arr.slice(index, index + chunk));\n    });\n    return result;\n};\n\n/**\n * Returns an array with every falsey value removed out.\n *\n * @function arrCompact\n * @memberof Array\n * @since 1.0.0\n * @param {any[]} arr\n * @returns {any[]}\n * @example\n * // returns [1, 2, 3, 4, 5]\n * arrCompact([1, \"\", \"\", 2, 3, null, 4, undefined, 5, \"\"])\n */\nconst arrCompact = (arr) => arr.filter((val) => val);\n\n/**\n * Counts how many times an element appears in an array.\n *\n * @function arrCount\n * @memberof Array\n * @since 2.0.0\n * @param {any[]} arr\n * @returns {Map<any, number>} Map<element: any, count: number>\n * @example\n * // returns Map{1: 4, 2: 2, 3: 1, 4: 1}\n * arrCount([1, 1, 2, 2, 1, 3, 4, 1])\n */\nconst arrCount = (arr) => {\n    const result = new _Map();\n    forEach(arr, val => result.set(val, result.has(val) ? result.get(val) + 1 : 1));\n    return result;\n};\n\n/**\n * Returns an array of all elements that exist in the first array, but not any others.\n *\n * @function arrDifference\n * @memberof Array\n * @since 2.0.0\n * @param {any[]} arr\n * @param {...any[]} values\n * @returns {any[]}\n * @example\n * // returns [2]\n * arrDifference([1, 2, 3], [1, \"foo\", 3])\n *\n * @example\n * // returns [1, 3]\n * arrDifference([1, 2, 3], [\"foo\"], [2, 0, 2])\n */\nconst arrDifference = (arr, ...values) => {\n    const valuesCounted = arrCount([].concat(...values));\n    // @ts-ignore: ts seems to pull the wrong data for arrCount\n    return arr.filter(item => !valuesCounted.has(item));\n};\n\n/**\n * Recursively flattens an array.\n *\n * @function arrFlattenDeep\n * @memberof Array\n * @since 1.0.0\n * @param {any[]} arr\n * @returns {any[]}\n * @example\n * // returns [1, 2, 3]\n * arrFlattenDeep([1, 2, [3]])\n *\n * @example\n * // returns [1, 2, 3, 5, 6, 6]\n * arrFlattenDeep([1, 2, [3, [[[5]]], [6, [6]]])\n */\nconst arrFlattenDeep = (arr) => {\n    const result = [];\n    forEach(arr, val => {\n        if (isArray(val)) {\n            result.push(...arrFlattenDeep(val));\n        }\n        else {\n            result.push(val);\n        }\n    });\n    return result;\n};\n\n/**\n * Creates a new array with the values of the input iterable.\n *\n * `Array.from` shorthand.\n *\n * @function arrFrom\n * @memberof Array\n * @since 1.0.0\n * @param {any} arr\n * @returns {any[]}\n * @example\n * // returns a = [1, 2, 3], b = [1, 10, 3]\n * const a = [1, 2, 3];\n * const b = arrFrom(a);\n *\n * b[1] = 10;\n */\nconst arrFrom = _Array.from;\n\n/**\n * Recursively maps the values of the input array with the iterator function and return the result.\n *\n * @function arrMapDeep\n * @memberof Array\n * @since 1.0.0\n * @param {any[]} arr\n * @param {function} fn fn(val: any, index: number, arr: any[])\n * @returns {any[]}\n * @example\n * // returns [4, 8, [2, 2, [32], 8]]\n * arrMapDeep([2, 4, [1, 1, [16], 4]], val => val * 2)\n */\nconst arrMapDeep = (arr, fn) => arr.map((val, index) => isArray(val) ? arrMapDeep(val, fn) : fn(val, index, arr));\n\n/**\n * Recursively creates a new array with the values of the input iterable.\n *\n * @function arrFromDeep\n * @memberof Array\n * @since 2.0.0\n * @param {any} arr\n * @returns {any[]}\n * @example\n * // returns a = [1, 2, 3, [5, [6]]], b = [1, 2, 3, [5, [10]]]\n * const a = [1, 2, 3, [5, [6]]];\n * const b = arrFromDeep(a);\n *\n * b[3][1][0] = 10;\n */\nconst arrFromDeep = (arr) => arrMapDeep(arrFrom(arr), val => (isArray(val) ? arrFrom(val) : val));\n\n/**\n * Returns an array of all elements that exist in the first array and at least once in one of the other arrays.\n *\n * @function arrIntersection\n * @memberof Array\n * @since 2.0.0\n * @param {any[]} arr\n * @param {...any[]} values\n * @returns {any[]}\n * @example\n * // returns [1, 3]\n * arrIntersection([1, 2, 3], [1, \"foo\", 3])\n *\n * @example\n * // returns [2]\n * arrIntersection([1, 2, 3], [\"foo\"], [2, 0, 2])\n */\nconst arrIntersection = (arr, ...values) => {\n    const valuesCounted = arrCount([].concat(...values));\n    // @ts-ignore: ts seems to pull the wrong data for arrCount\n    return arr.filter(item => valuesCounted.has(item));\n};\n\n/**\n * Checks if a number is in the given range.\n *\n * @function numberInRange\n * @memberof Number\n * @since 1.0.0\n * @param {number} val\n * @param {number} min\n * @param {number} max\n * @returns {boolean}\n * @example\n * // returns true\n * numberInRange(0.5, 0, 1)\n * numberInRange(1, 0, 1)\n * numberInRange(0, -5, 5)\n *\n * @example\n * // returns false\n * numberInRange(-1, 0, 5)\n * numberInRange(10, 0, 5)\n */\nconst numberInRange = (val, min, max) => val >= min && val <= max;\n\n/**\n * Returns a new array with the item at the index removed.\n *\n * @function arrRemoveIndex\n * @memberof Array\n * @since 2.8.0\n * @param {any[]} arr\n * @param {number} index\n * @returns {any[]}\n * @example\n * // returns [\"foo\", \"fizz\"]\n * arrRemoveIndex([\"foo\", \"bar\", \"fizz\"], 1)\n */\nconst arrRemoveIndex = (arr, index) => {\n    if (!numberInRange(index, 0, arr.length - 1)) {\n        return arr;\n    }\n    return index === 0\n        ? arr.slice(1)\n        : arr.slice(0, index).concat(arr.slice(index + 1));\n};\n\n/**\n * Returns a new array with the first occurrence of the item removed.\n *\n * @function arrRemoveItem\n * @memberof Array\n * @since 2.8.0\n * @param {any[]} arr\n * @param {any} item\n * @returns {any[]}\n * @example\n * // returns [\"foo\", \"fizz\"]\n * arrRemoveItem([\"foo\", \"bar\", \"fizz\"], \"bar\")\n */\nconst arrRemoveItem = (arr, item) => arr.includes(item) ? arrRemoveIndex(arr, arr.indexOf(item)) : arr;\n\n/**\n * Returns a new array with every n-th item from the input array.\n *\n * @function arrStep\n * @memberof Array\n * @since 1.0.0\n * @param {any[]} arr\n * @param {number} step\n * @returns {any[]}\n * @example\n * // returns [1, 3, 5]\n * arrStep([1, 2, 3, 4, 5, 6], 2)\n */\nconst arrStep = (arr, step) => arr.filter((val, index) => index % step === 0);\n\n/**\n * Returns an array of all unique elements in an array.\n *\n * @function arrUniq\n * @memberof Array\n * @since 1.0.0\n * @param {any[]} arr\n * @returns {any[]}\n * @example\n * // returns [1, 2, 3, 4]\n * arrUniq([1, 1, 1, 2, 3, 1, 2, 1, 4])\n */\nconst arrUniq = (arr) => arrFrom(new _Set(arr));\n\n/**\n * Merges contents of two objects.\n *\n * `Object.assign` shorthand.\n *\n * @function objMerge\n * @memberof Object\n * @since 2.7.0\n * @param {Object} obj\n * @param {Object} objSecondary\n * @returns {Object}\n * @example\n * // returns {a: 1, b: 2}\n * objMerge({a: 1}, {b: 2})\n */\nconst objMerge = _Object.assign;\n\n/**\n * Creates a new object with the entries of the input object.\n *\n * @function objFrom\n * @memberof Object\n * @since 1.0.0\n * @param {Object} obj\n * @returns {Object}\n * @example\n * // returns a = {a: 4, b: 2}, b = {a: 10, b: 2}\n * const a = {a: 4, b: 2};\n * const b = objFrom(a);\n *\n * b.a = 10;\n */\nconst objFrom = (obj) => objMerge({}, obj);\n\n/**\n * Sets every nil property of object to the value from the default object.\n *\n * @function objDefaults\n * @memberof Object\n * @since 2.6.0\n * @param {Object} obj\n * @param {Object} objDefault\n * @returns {Object}\n * @example\n * // returns a = {a: 1, b: 2, c: 5}\n * objDefaults({a: 1, c: 5}, {a: 1, b: 2, c: 3})\n */\nconst objDefaults = (obj, objDefault) => {\n    const result = isArray(obj) ? arrFrom(obj) : objFrom(obj);\n    forEachEntry(objDefault, (keyDefault, valDefault) => {\n        if (!hasKey(obj, keyDefault)) {\n            result[keyDefault] = valDefault;\n        }\n    });\n    return result;\n};\n\n/**\n * Maps each entry of an object and returns the result.\n *\n * @function objMap\n * @memberof Object\n * @since 1.0.0\n * @param {Object} obj\n * @param {function} fn fn(key: any, val: any, index: number, arr: any[])\n * @returns {Object}\n * @example\n * // returns a = {a: 8, b: 4}\n * objMap({a: 4, b: 2}, (key, val) => val * 2)\n */\nconst objMap = (obj, fn) => {\n    const objNew = {};\n    forEachEntry(obj, (key, val, index) => {\n        objNew[key] = fn(key, val, index, obj);\n    });\n    return objNew;\n};\n\n/**\n * Recursively maps each entry of an object and returns the result.\n *\n * @function objMapDeep\n * @memberof Object\n * @since 1.0.0\n * @param {Object} obj\n * @param {function} fn fn(key: any, val: any, index: number, arr: any[])\n * @returns {Object}\n * @example\n * // returns {a: {b: 4, c: [20, 40]}}\n * arrMapDeep({a: {b: 2, c: [10, 20]}}, (key, val) => val * 2)\n */\nconst objMapDeep = (obj, fn) => objMap(obj, (key, val, index, objNew) => isObjectLike(val)\n    ? objMapDeep(val, fn)\n    : fn(key, val, index, objNew));\n\n/**\n * Deeply creates a new object with the entries of the input object.\n *\n * @function objFromDeep\n * @memberof Object\n * @since 1.0.0\n * @param {Object} obj\n * @returns {Object}\n * @example\n * // returns a = {a: {b: 2, c: {a: 10, b: 20}}, b = {a: {b: 2, c: {a: 123, b: 20}}}\n * const a = {a: {b: 2, c: {a: 10, b: 20}}};\n * const b = objFromDeep(a);\n *\n * b.a.c.a = 123;\n */\nconst objFromDeep = (obj) => objMapDeep(objFrom(obj), (key, val) => (isObjectLike(val) ? objFrom(val) : val));\n\n/**\n * Recursively sets every nil property of object to the value from the default object.\n *\n * @function objDefaultsDeep\n * @memberof Object\n * @since 2.7.0\n * @param {Object} obj\n * @param {Object} objDefault\n * @returns {Object}\n * @example\n * // returns a = {a: [1, 2, 3], b: 2, c: {f: \"x\"}}\n * objDefaultsDeep({a: [1, 2], c: {f: \"x\"}}, {a: [1, 2, 3], b: 2, c: {f: \"y\"}})\n */\nconst objDefaultsDeep = (obj, objDefault) => {\n    const result = isArray(obj) ? arrFrom(obj) : objFromDeep(obj);\n    forEachEntry(objDefault, (keyDefault, valDefault) => {\n        const valGiven = obj[keyDefault];\n        if (isObjectLike(valDefault)) {\n            result[keyDefault] = isObjectLike(valGiven)\n                ? objDefaultsDeep(valGiven, valDefault)\n                : valDefault;\n        }\n        else {\n            result[keyDefault] = isUndefined(valGiven) ? valDefault : valGiven;\n        }\n    });\n    return result;\n};\n\n/**\n * Adds a property to an object with optional custom flags.\n *\n * `Object.defineProperty` shorthand.\n *\n * @function objDefineProperty\n * @memberof Object\n * @since 2.8.0\n * @param {Object} obj\n * @param {string} key\n * @param {any} val\n * @param {boolean} [enumerable=true]\n * @param {boolean} [writable=true]\n * @param {boolean} [configurable=true]\n * @returns {Object}\n * @example\n * // returns a = {\"foo\": 1}\n * const a={};\n * objDefineProperty(a, \"foo\", 1)\n */\nconst objDefineProperty = (obj, key, val, enumerable = true, writable = true, configurable = true) => _Object.defineProperty(obj, key, {\n    value: val,\n    enumerable,\n    writable,\n    configurable\n});\n\n/**\n * Returns an array of the objects values.\n *\n * `Object.values` shorthand.\n *\n * @function objValues\n * @memberof Object\n * @since 1.0.0\n * @param {Object} obj\n * @returns {any[]}\n * @example\n * // returns [1, 2, 3]\n * objValues({a: 1, b: 2, c: 3})\n */\nconst objValues = _Object.values;\n\n/**\n * Creates a map from an object.\n *\n * @function mapFromObject\n * @memberof Map\n * @since 1.0.0\n * @param {Object} obj\n * @returns {Map}\n * @example\n * // returns Map{a: 1, b: 4, c: 5}\n * mapFromObject({a: 1, b: 4, c: 5})\n */\nconst mapFromObject = (obj) => new _Map(objEntries(obj));\n\n/**\n * Wrapper around try/catch.\n *\n * Returns the function result or, if an error is thrown, the error.\n *\n * @function fnAttempt\n * @memberof Fn\n * @since 3.2.0\n * @param {Function} fn\n * @param {...any[]} args\n * @returns {any|error}\n * @example\n * const foo = (a, b) => {\n *  if(b > 10){\n *    throw new RangeError();\n *  }\n *\n *  return a + b;\n * };\n *\n * fnAttempt(foo, 2, 1)   //=> 3\n * fnAttempt(foo, 2, 500) //=> RangeError\n */\nconst fnAttempt = (fn, ...args) => {\n    try {\n        return fn(...args);\n    }\n    catch (err) {\n        return err;\n    }\n};\n\n/**\n * Returns a curried function.\n *\n * A curried function can take between zero and n arguments,\n * where n is either the functions argument length or the provided arity.\n * As soon as n arguments are reached, the function is run with all arguments\n *\n * @function fnCurry\n * @memberof Fn\n * @since 3.2.0\n * @param {Function} fn\n * @param {number} [arity=fn.length]\n * @returns {Function}\n * @example\n * const foo = (a, b, c) => [a, b, c];\n * const fooCurried = fnCurry(foo);\n *\n * fooCurried(1)(2)(3) //=> [1, 2, 3]\n * fooCurried(1, 2)(3) //=> [1, 2, 3]\n * fooCurried(1, 2, 3) //=> [1, 2, 3]\n */\nconst fnCurry = (fn, arity = fn.length) => {\n    // tslint:disable-next-line\n    const resolver = function () {\n        const argsBase = arguments;\n        // tslint:disable-next-line\n        return function () {\n            const args = [...argsBase, ...arguments];\n            const result = args.length >= arity ? fn : resolver;\n            return result(...args);\n        };\n    };\n    return resolver();\n};\n\n/**\n * Throttles a function to only run every n ms.\n *\n * Useful for event handlers that fire several times a second, such as scroll or resize\n *\n * @function fnThrottle\n * @memberof Fn\n * @since 3.1.0\n * @param {Function} fn\n * @param {number} timeout\n * @param {boolean} [immediate=false]\n * @returns {Function}\n * @example\n * const foo = (a, b) => console.log(a + b);\n * const fooThrottled = fnThrottle(foo, 500); // function that can only run every 500ms\n */\nconst fnThrottle = (fn, timeout, immediate = false) => {\n    const getTimer = () => setTimeout(() => {\n        canRun = true;\n        clearTimeout(timer);\n    }, timeout);\n    let canRun = immediate;\n    let timer = immediate ? -1 : getTimer();\n    return function () {\n        if (canRun) {\n            canRun = false;\n            timer = getTimer();\n            // @ts-ignore\n            return fn.apply(this, arguments);\n        }\n    };\n};\n\n/**\n * Clamps a number in a given range.\n *\n * @function numberClamp\n * @memberof Number\n * @since 1.0.0\n * @param {number} val\n * @param {number} min\n * @param {number} max\n * @returns {number}\n * @example\n * numberClamp(5, 0, 10)    //=> 5\n * numberClamp(-2, 0, 10)   //=> 0\n * numberClamp(99, 0, 10)   //=> 10\n */\nconst numberClamp = (val, min, max) => {\n    if (val < min) {\n        return min;\n    }\n    else if (val > max) {\n        return max;\n    }\n    return val;\n};\n\n/**\n * Return a random float or integer number in the given range.\n *\n * @function randomNumber\n * @memberof Random\n * @since 3.0.0\n * @param {number} [min=0]\n * @param {number} [max=1]\n * @param {boolean} [floating=true]\n * @returns {number}\n * @example\n * randomNumber()               //=> 0.56832138\n * randomNumber(0, 100)         //=> 54.2135123\n * randomNumber(2, 10, false)   //=> 5\n */\nconst randomNumber = (min = 0, max = 1, floating = true) => {\n    const diff = max - min;\n    if (diff === 0) {\n        return min;\n    }\n    const rand = min + _Math.random() * diff;\n    return floating ? rand : _Math.floor(rand / diff * (diff + 1));\n};\n\n/**\n * Return a random item from an array.\n *\n * @function randomItem\n * @memberof Random\n * @since 3.0.0\n * @param {any[]} arr\n * @returns {any}\n * @example\n * randomItem([\"foo\", \"bar\"])      //=> \"foo\"\n * randomNumber([1, 2, 3, 4, 5])   //=> 3\n */\nconst randomItem = (arr) => arr[randomNumber(0, arr.length - 1, false)];\n\n/**\n * Value, type checking and comparison\n * @namespace Is\n */\n/**\n * Checks if a target has something\n * @namespace Has\n */\n/**\n * Gets target data\n * @namespace Get\n */\n/**\n * Looping through iterables\n * @namespace For\n */\n/**\n * Array manipulation and analysis\n * @namespace Array\n */\n/**\n * Object manipulation and analysis\n * @namespace Object\n */\n/**\n * Map manipulation and analysis\n * @namespace Map\n */\n/**\n * Function manipulation\n * @namespace Fn\n */\n/**\n * Number generation and checking\n * @namespace Number\n */\n/**\n * Random number generation\n * @namespace Random\n */\n\nexport { isEqual, isInstanceOf, isTypeOf, isUndefined, isDefined, isNil, isPrimitive, isNumber, isString, isBoolean, isSymbol, isObject, isObjectLike, isObjectPlain, isArray, isArrayLike, isArrayBuffer, isArrayTyped, isPromise, isMap, isSet, isDate, isRegExp, isFunction, isArguments, isError, isEmpty, isInteger, hasKey, hasPath, hasOwnProperty, getPath, forTimes, forEach, forEachDeep, forEachEntry, forEachEntryDeep, arrFrom, arrFromDeep, arrMapDeep, arrFlattenDeep, arrCompact, arrChunk, arrStep, arrRemoveIndex, arrRemoveItem, arrCount, arrDifference, arrIntersection, arrUniq, objFrom, objFromDeep, objMap, objMapDeep, objDefaults, objDefaultsDeep, objMerge, objDefineProperty, objKeys, objValues, objEntries, mapFromObject, fnThrottle, fnAttempt, fnCurry, numberInRange, numberClamp, randomNumber, randomItem };\n"],"names":[],"mappings":";;;AAAA;;;;;;;;;;;;;;;;;;;AAmBA,AA2EA;;;;;;;;;;;;;;;;;;;;AAoBA,MAAM,YAAY,GAAG,CAAC,GAAG,EAAE,MAAM,KAAK,GAAG,YAAY,MAAM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}