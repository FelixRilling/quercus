{"version":3,"file":"quercus.js","sources":["esm/src/lookup/LookupStrategy.js","esm/src/tree/TreeNode.js"],"sourcesContent":["/**\n * Strategy to use when checking for a paths existence in a tree.\n * The strategy is used to check the final node only.\n *\n * @public\n */\nvar LookupStrategy;\n(function (LookupStrategy) {\n    /**\n     * Every node is considered to exist, regardless its value.\n     */\n    LookupStrategy[LookupStrategy[\"EXISTENCE_BY_NODE\"] = 0] = \"EXISTENCE_BY_NODE\";\n    /**\n     * Only nodes which have a non-nil value are considered existent.\n     */\n    LookupStrategy[LookupStrategy[\"EXISTENCE_BY_VALUE\"] = 1] = \"EXISTENCE_BY_VALUE\";\n})(LookupStrategy || (LookupStrategy = {}));\nexport { LookupStrategy };\n//# sourceMappingURL=LookupStrategy.js.map","import { isEmpty, isNil } from \"lodash\";\nimport { LookupStrategy } from \"../lookup/LookupStrategy\";\n/**\n * Default implementation of a tree, using nested maps.\n *\n * @public\n * @class\n */\nclass TreeNode {\n    /**\n     * Creates a new instance with an optional value.\n     *\n     * @param value Value to instantiate the node with. If none is provided, null is set.\n     */\n    constructor(value = null) {\n        this.value = value;\n        this.paths = new Map();\n    }\n    /**\n     * Checks if a given path exists in this tree.\n     *\n     * @public\n     * @param path Path to check for. May not be empty.\n     * @param lookupStrategy Strategy to use. See {@link LookupStrategy} for details.\n     * @return if the path exists, based on the strategy used.\n     */\n    hasPath(path, lookupStrategy = LookupStrategy.EXISTENCE_BY_NODE) {\n        this.validatePath(path);\n        const lookupResult = this.resolvePath(path, 0 /* RETURN_ON_MISSING */);\n        if (isNil(lookupResult.node)) {\n            return false;\n        }\n        if (lookupStrategy === LookupStrategy.EXISTENCE_BY_NODE) {\n            return true;\n        }\n        return !isNil(lookupResult.node.value);\n    }\n    /**\n     * Gets a given path in this tree.\n     *\n     * @public\n     * @param path Path to get. May not be empty.\n     * @return lookup result, containing details about which node was retrieved and what path was used.\n     */\n    getPath(path) {\n        this.validatePath(path);\n        return this.resolvePath(path, 0 /* RETURN_ON_MISSING */);\n    }\n    /**\n     * Sets a value for a given path.\n     * Middle nodes will be created automatically.\n     *\n     * @public\n     * @param path Path to set the value for. May not be empty.\n     * @param value Value to set.\n     */\n    setPath(path, value) {\n        this.validatePath(path);\n        const lookupResult = this.resolvePath(path, 1 /* CREATE_MISSING */);\n        const node = lookupResult.node;\n        node.value = value;\n    }\n    /**\n     * Resolves the path against this tree.\n     *\n     * @private\n     * @param path Path to resolve\n     * @param resolverStrategy Strategy to use for non-existent nodes.\n     * @param previousPath Only used for recursive calls. Path the resolving was delegated from.\n     * @return Lookup result.\n     */\n    resolvePath(path, resolverStrategy, previousPath = []) {\n        const key = path[0];\n        let node;\n        if (!this.paths.has(key)) {\n            if (resolverStrategy !== 1 /* CREATE_MISSING */) {\n                return {\n                    node: null,\n                    parent: {\n                        node: this,\n                        key\n                    },\n                    matchedPath: previousPath,\n                    trailingPath: path\n                };\n            }\n            node = new TreeNode();\n            this.paths.set(key, node);\n        }\n        else {\n            node = this.paths.get(key);\n        }\n        const previousPathNew = Array.from(previousPath);\n        previousPathNew.push(key);\n        if (path.length === 1) {\n            return {\n                node,\n                parent: {\n                    node: this,\n                    key\n                },\n                matchedPath: previousPathNew,\n                trailingPath: []\n            };\n        }\n        const nextPath = path.slice(1);\n        return node.resolvePath(nextPath, resolverStrategy, previousPathNew);\n    }\n    /**\n     * Validates a given path.\n     *\n     * @param path Path to check.\n     * @private\n     */\n    validatePath(path) {\n        if (isEmpty(path)) {\n            throw new TypeError(\"Path may not be empty.\");\n        }\n    }\n}\nexport { TreeNode };\n//# sourceMappingURL=TreeNode.js.map"],"names":["LookupStrategy","isNil","isEmpty"],"mappings":"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"}